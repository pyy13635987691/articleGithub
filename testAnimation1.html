
<!doctype html>
<html  lang="zh">
 <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">

  <title>增加“毫秒表”模型，基于时间维度的事件探索</title>
  
   <style>
    body, html {
      height: 100%;
     }

    body {
      margin: 0;
      padding: 0;
      font-family:Arial, Sans-Serif;
      background-color: black ; 
    }

     #app {
      position: relative ;
     }

     img#bgimage {
      position: absolute ;
      animation: fadein 600ms;
	  opacity: 0.3 ;
    }


    @keyframes fadein {
      from { opacity: 0; }
      to { opacity: 0.3; }
    }
	ol{color:rgb(150,250,100);
	  font-size:1.5em;
	  font-family:"Consolas"}
	ol>li{
	  text-indent: 0.5em ;
	  margin-left: 1em ;
	}
	</style>
	<script type="text/javascript">
	<!--
	 var timer = { //设计一个毫秒计时器模型，该模型可以同时并行记录多个事件的发生经历的时间，开发者字符串（msg）作为时钟的唯一标识，当timer.begin(msg)运行开启计时，而timer.end(msg)用于结束该标识的计时，返回毫秒级别的时间差。
	         clock : [] ,
			 begin : function(msg){
			          let beginTime = new Date() - 0 ;
					  let beginLable = msg ;
					  this.clock.push( {beginTime , beginLable } ) ;
			  }, // timer.begin
			 end :  function(msg){
			         let endTime = new Date() - 0 ;
					 let clock  ;
					 let length = this.clock.length ;
					 for (let i = 0 ; i < length ; i++ ){ 
					 //设计一个交换算法，将找到即将结束时钟对象，从timer.clock数组中删除。
						 if (this.clock[i].beginLable === msg){
							 clock = this.clock[i] ;
							 this.clock[i] = this.clock[length-1] ;
							 this.clock.pop();
                             return endTime - clock.beginTime ;
							}
					 }
					 throw("你错误地使用了计时器：timer.end方法，查看参数："+ msg);
					 
			  }, // timer.end 
			} ;

		 //window对象开始读取页面所需的资源文件
		 timer.begin('windowLoad') ; 
		 
		 window.addEventListener('load',function(){
           let time =  timer.end('windowLoad') ;
		   print("APP加载完成所有资源文件，共使用 " + time + " ms!") ;
		 }) ;


	timer.end('wrong parameter') ; //故意写错，用来测试计时器模型的参数。
	//-->
	</script>
  </head>
  <body>
   <div id="app">
    <img id="bgimage" src="lesson/CS.jpg" >
	<ol id="ol">
		
	</ol>
   </div>
   <script type="text/javascript">
   <!--
    print("本程序用异步代码实现了文字动画。主要是创作性地利用函数的对象特性，让print函数能智能判断当前的异步输出的完成情况，并结合requestAnimationFrame这个强大API实现动画，每个字符的细节动画输出和整个字符串的整体有序把控到位！");

	
 const backImgs = [] ; //全局变量
 {   
	const booksPage = ['CS.jpg' , 'nutrition.jpg' , 'webProgramming.jpg' ] ;

	for (let book of booksPage ){
		timer.begin(book) ;
		let img = new Image() ;
		img.src = "lesson/" + book ;
		img.id = "bgimage" ;
		img.addEventListener('load',function(){
		    print("图像:" + book + "完成load事件要 " + timer.end(book) +'ms !');
		});
		backImgs.push(img) ;
	}
 }
  //为什么下面这几条事件处理函数不能写在head标签中呢？但是window.load事件则可以？用这个例子可以了解Web APP的对象世界的建立顺序。
	document.body.addEventListener("click", function(){
	  let randI =  parseInt(Math.random() *  backImgs.length) ;
	  $("app").replaceChild(backImgs[randI],$("bgimage"));
	}) ;
    window.document.body.addEventListener('keydown',function(ev){
            timer.begin('key'+ev.key) ;
			 }) ;
	window.document.body.addEventListener('keyup',function(ev){
		  let time =  timer.end('key'+ev.key) ;
		  print("您刚才敲： "+ ev.key  + "键，用了" + time +  " ms!") ;
		 }) ;

	print("Hello , this App will check the preformace of you computing system! ") ;
	print("I'm very good at programmming! ") ;
	print("Recursive function can do a lot of pretty good things! ") ;
    function print(str){
	  if (print.str){ //如果存在print.str则说明print函数正在异步输出中
		  setTimeout(()=>print(str) , 1000) ;
		  return ;
	  }
	  print.str= str ;
	  let liDom = document.createElement('li') ;
	  let olDom = $("ol");
	  
	  liDom.textContent = print.str[0] ; 
	  window.requestAnimationFrame(oneChar);
	   function oneChar(){
		 if(print.str.length > 1){
	      liDom.textContent += print.str[1] ;
          print.str = print.str.slice(1) ;
		  window.requestAnimationFrame(oneChar);
		  }else{
		   print.str = undefined ;
		  }
	   }
	   
	  olDom.appendChild(liDom);
	} // print(str)
    


	function $(eleId){
     if (typeof eleId !== 'string'){
	   throw("$函数调用实参错误，行参必须是字符串！");
	   return 
     }
      return document.getElementById(eleId) ;
    }
   //-->
   </script> 
  </body>
 </html>